{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":["file:///Users/lunaaziz/tutorial-page/ktutorial/node_modules/tinacms/dist/node-cache-5e8db9f0.mjs"],"sourcesContent":["const makeCacheDir = async (dir, fs, path, os) => {\n  const pathParts = dir.split(path.sep).filter(Boolean);\n  const cacheHash = pathParts[pathParts.length - 1];\n  const rootUser = pathParts[0];\n  let cacheDir = dir;\n  if (!fs.existsSync(path.join(path.sep, rootUser))) {\n    cacheDir = path.join(os.tmpdir(), cacheHash);\n  }\n  try {\n    fs.mkdirSync(cacheDir, { recursive: true });\n  } catch (error) {\n    throw new Error(`Failed to create cache directory: ${error.message}`);\n  }\n  return cacheDir;\n};\nconst NodeCache = async (dir) => {\n  const fs = require(\"node:fs\");\n  const path = require(\"node:path\");\n  const os = require(\"node:os\");\n  const { createHash } = require(\"node:crypto\");\n  const cacheDir = await makeCacheDir(dir, fs, path, os);\n  return {\n    makeKey: (key) => {\n      const input = key && key instanceof Object ? JSON.stringify(key) : key || \"\";\n      return createHash(\"sha256\").update(input).digest(\"hex\");\n    },\n    get: async (key) => {\n      let readValue;\n      const cacheFilename = `${cacheDir}/${key}`;\n      try {\n        const data = await fs.promises.readFile(cacheFilename, \"utf-8\");\n        readValue = JSON.parse(data);\n      } catch (e) {\n        if (e.code !== \"ENOENT\") {\n          console.error(\n            `Failed to read cache file to ${cacheFilename}: ${e.message}`\n          );\n        }\n      }\n      return readValue;\n    },\n    set: async (key, value) => {\n      const cacheFilename = `${cacheDir}/${key}`;\n      try {\n        await fs.promises.writeFile(cacheFilename, JSON.stringify(value), {\n          encoding: \"utf-8\",\n          flag: \"wx\"\n          // Don't overwrite existing caches\n        });\n      } catch (e) {\n        if (e.code !== \"EEXIST\") {\n          console.error(\n            `Failed to write cache file to ${cacheFilename}: ${e.message}`\n          );\n        }\n      }\n    }\n  };\n};\nexport {\n  NodeCache,\n  makeCacheDir\n};\n"],"names":[],"mappings":";;;;AAAA,MAAM,eAAe,OAAO,KAAK,IAAI,MAAM;IACzC,MAAM,YAAY,IAAI,KAAK,CAAC,KAAK,GAAG,EAAE,MAAM,CAAC;IAC7C,MAAM,YAAY,SAAS,CAAC,UAAU,MAAM,GAAG,EAAE;IACjD,MAAM,WAAW,SAAS,CAAC,EAAE;IAC7B,IAAI,WAAW;IACf,IAAI,CAAC,GAAG,UAAU,CAAC,KAAK,IAAI,CAAC,KAAK,GAAG,EAAE,YAAY;QACjD,WAAW,KAAK,IAAI,CAAC,GAAG,MAAM,IAAI;IACpC;IACA,IAAI;QACF,GAAG,SAAS,CAAC,UAAU;YAAE,WAAW;QAAK;IAC3C,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,MAAM,CAAC,kCAAkC,EAAE,MAAM,OAAO,EAAE;IACtE;IACA,OAAO;AACT;AACA,MAAM,YAAY,OAAO;IACvB,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM,EAAE,UAAU,EAAE;IACpB,MAAM,WAAW,MAAM,aAAa,KAAK,IAAI,MAAM;IACnD,OAAO;QACL,SAAS,CAAC;YACR,MAAM,QAAQ,OAAO,eAAe,SAAS,KAAK,SAAS,CAAC,OAAO,OAAO;YAC1E,OAAO,WAAW,UAAU,MAAM,CAAC,OAAO,MAAM,CAAC;QACnD;QACA,KAAK,OAAO;YACV,IAAI;YACJ,MAAM,gBAAgB,GAAG,SAAS,CAAC,EAAE,KAAK;YAC1C,IAAI;gBACF,MAAM,OAAO,MAAM,GAAG,QAAQ,CAAC,QAAQ,CAAC,eAAe;gBACvD,YAAY,KAAK,KAAK,CAAC;YACzB,EAAE,OAAO,GAAG;gBACV,IAAI,EAAE,IAAI,KAAK,UAAU;oBACvB,QAAQ,KAAK,CACX,CAAC,6BAA6B,EAAE,cAAc,EAAE,EAAE,EAAE,OAAO,EAAE;gBAEjE;YACF;YACA,OAAO;QACT;QACA,KAAK,OAAO,KAAK;YACf,MAAM,gBAAgB,GAAG,SAAS,CAAC,EAAE,KAAK;YAC1C,IAAI;gBACF,MAAM,GAAG,QAAQ,CAAC,SAAS,CAAC,eAAe,KAAK,SAAS,CAAC,QAAQ;oBAChE,UAAU;oBACV,MAAM;gBAER;YACF,EAAE,OAAO,GAAG;gBACV,IAAI,EAAE,IAAI,KAAK,UAAU;oBACvB,QAAQ,KAAK,CACX,CAAC,8BAA8B,EAAE,cAAc,EAAE,EAAE,EAAE,OAAO,EAAE;gBAElE;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}}]
}